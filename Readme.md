# Docker
Docker is a platform that allows you to build, run, and manage applications in isolated environments called **containers**. Containers package an application with all its dependencies, ensuring it works consistently across different systems.

# Container
A container is a lightweight, standalone, and executable unit of software that includes everything needed to run an application‚Äîsuch as the code, runtime, libraries, and system tools. Containers are isolated from each other and the host system, ensuring consistency across different environments (development, testing, production).

They're often compared to virtual machines but are much more efficient because they share the host system's operating system kernel.

# Why We Need Containers

1. **Consistency Across Environments**  
   - Containers package applications and their dependencies, ensuring they run the same way across systems (e.g., development, testing, production).  
   - Solves the "it works on my machine" problem.  

2. **Isolation**  
   - Containers isolate applications, preventing dependency conflicts and ensuring security and stability.  

3. **Portability**  
   - Containers are lightweight and portable, making it easy to move applications between systems or platforms (e.g., from on-premises to the cloud).  

4. **Efficiency**  
   - Containers share the host OS kernel, using fewer resources compared to virtual machines, which require separate OS installations.  

5. **Faster Deployment**  
   - Containers start quickly, enabling rapid deployment and scaling of applications.  

6. **Improved Scalability**  
   - Applications can be scaled horizontally by deploying multiple container instances easily.  

7. **Easier CI/CD Pipelines**  
   - Containers streamline continuous integration and deployment by providing consistent environments for building, testing, and deploying code.  

# Bare Metal vs Virtual Machines (VMs) vs Containers

| Feature              | **Bare Metal**                     | **Virtual Machines (VMs)**                 | **Containers**                          |
|----------------------|-------------------------------------|--------------------------------------------|-----------------------------------------|
| **Definition**       | Direct use of physical hardware.   | Runs on a hypervisor with separate OS for each VM. | Lightweight environments sharing the host OS kernel. |
| **Performance**      | Best performance, no overhead.     | Moderate performance, some overhead due to hypervisor. | Near-native performance, minimal overhead. |
| **Isolation**        | No isolation (shared hardware).    | Strong isolation with separate OS.         | Process-level isolation using namespaces and cgroups. |
| **Startup Time**     | Immediate (OS already running).    | Slow (full OS boot).                       | Very fast (seconds to milliseconds).    |
| **Resource Usage**   | Entire hardware dedicated.         | High (each VM has its own OS).             | Low (shared OS kernel, minimal footprint). |
| **Scalability**      | Limited by physical hardware.      | Moderate (requires more hardware).         | High (can run many containers on one host). |
| **Portability**      | Tied to specific hardware.         | Limited portability between hypervisors.   | Highly portable across systems supporting containers. |
| **Use Case**         | Performance-critical applications. | Running multiple OS instances on one host. | Microservices, cloud-native applications. |

# Building Blocks of Docker

1. **Docker Engine**  
   - The core of Docker that runs and manages containers. It includes:  
     - **Docker Daemon**: Handles container management, image building, and communication with the host.  
     - **Docker CLI**: Command-line interface for interacting with Docker.  

2. **Docker Image**  
   - A lightweight, read-only template that contains the application and its dependencies.  
   - Used to create containers.  

3. **Docker Container**  
   - A runnable instance of a Docker image.  
   - Provides an isolated environment for running applications.  

4. **Docker Hub**  
   - A public repository for storing and sharing Docker images.  
   - Includes official images and allows users to upload custom images.  

5. **Docker Compose**  
   - A tool for defining and managing multi-container applications using a YAML file.  
   - Simplifies running services together (e.g., a web app and its database).  

6. **Dockerfile**  
   - A text file with instructions to build a Docker image.  
   - Defines the application's environment and dependencies.  

7. **Docker Network**  
   - Provides communication between containers and the host system.  
   - Types include bridge, host, overlay, and custom networks.  

8. **Docker Volume**  
   - A mechanism for persisting data generated by containers.  
   - Allows sharing of data between containers and the host.  


# Docker Image layers

1. **What Are Image Layers?**  
   - Docker images are built in layers, where each layer represents a set of changes (e.g., adding files, installing dependencies, modifying configurations).  
   - Layers are immutable (cannot be changed) and are stacked to form the final image.  

2. **Base Layer**  
   - The first layer in an image, usually derived from a minimal OS or official base image (e.g., `ubuntu`, `alpine`).  
   - Other layers build on top of this.  

3. **Layer Caching**  
   - Docker uses layer caching to speed up image builds.  
   - If a layer has already been built and hasn't changed, Docker reuses it instead of rebuilding.  
   - Reduces build time and improves efficiency.  

4. **Layer Reuse**  
   - Layers are shared across multiple images if they use the same base and intermediate layers.  
   - Saves disk space by avoiding duplication.  

5. **Read-Only Layers**  
   - All layers in a Docker image are read-only.  
   - When a container runs, Docker adds a writable layer on top of the image layers, called the **container layer**.  

6. **Layered Structure Benefits**  
   - **Portability**: Layers can be shared across systems.  
   - **Efficiency**: Layer reuse reduces disk space and build times.  
   - **Version Control**: Changes are easy to track as each layer corresponds to a specific step in the `Dockerfile`.  

7. **Best Practices for Managing Layers**  
   - **Combine Commands**: Use multi-line instructions in the `Dockerfile` to minimize the number of layers.  
   - **Order Matters**: Place frequently changing instructions (e.g., adding application code) toward the end of the `Dockerfile` to maximize layer caching.  
   - **Use Small Base Images**: Start with lightweight base images (e.g., `alpine`) to keep images small.  

8. **Layer Storage**  
   - Layers are stored in Docker's storage backend (e.g., OverlayFS).  
   - They are identified by a unique hash.  

9. **Writable Layer in Containers**  
   - When running a container, changes made are stored in the writable layer.  
   - These changes are lost when the container is stopped unless persisted using volumes.  

10. **Removing Unused Layers**  
    - Use `docker system prune` to clean up unused layers and free up disk space.  



# Basic Docker Commands

###  1. Build a Docker Image üèóÔ∏è  
```sh
docker build -t my-node-app .
```
- Builds a Docker image from the current directory (`.`).  
- `-t my-node-app` assigns a name to the image.  


###  2. Run a Docker Container ‚ñ∂Ô∏è  
```sh
docker run -p 3000:3000 my-node-app
```
- Starts a container from the `my-node-app` image.  
- Maps **port 3000** of the container to **port 3000** on the host.  

#### Run in Detached Mode (-d) üèÉ  
```sh
docker run -d -p 3000:3000 my-node-app
```
- Runs the container in the background (detached mode).  


###  3. List Running Containers üìã  
```sh
docker ps
```
- Lists all **running** containers.  

```sh
docker ps -a
```
- Lists **all** containers (including stopped ones).  


###  4. Stop a Running Container ‚õî  
```sh
docker stop <container_id>
```
- Stops a running container by its **ID**.  


###  5. Remove a Container üóëÔ∏è  
```sh
docker rm <container_id>
```
- Deletes a **stopped** container.  

```sh
docker container prune
```
- Removes **all** stopped containers.  


###  6. Remove an Image ‚ùå  
```sh
docker rmi my-node-app
```
- Deletes the `my-node-app` image.  

```sh
docker image prune -a
```
- Removes **all unused** images.  


###  7. Name & Tag an Image üè∑Ô∏è  

#### Name and tag during build
```sh
docker build -t my-node-app:v1 .
```
- Tags the image as `v1`.  

#### Tag an existing image
```sh
docker tag my-node-app:v1 mydockerhubusername/my-node-app:v1
```
- Prepares the image for pushing to Docker Hub.  


###  8. Push an Image to Docker Hub üì§  
```sh
docker login
```
- Logs into Docker Hub.  

```sh
docker push mydockerhubusername/my-node-app:v1
```
- Pushes the image to Docker Hub.  


###  9. Pull an Image from Docker Hub üì•  
```sh
docker pull node:18-alpine
```
- Downloads the **Node.js Alpine** image from Docker Hub.  


###  10. Run a Container in Interactive Mode üíª  
```sh
docker run -it node:18-alpine sh
```
- Runs an interactive shell (`sh`) inside the container.  
- `-it` allows user interaction.  

To exit, type:
```sh
exit
```


###  11. View Container Logs üìú  
```sh
docker logs <container_id>
```
- Shows logs of the running container.  

```sh
docker logs -f <container_id>
```
- Follows real-time logs.  


###  12. Execute Commands in a Running Container üõ†Ô∏è  
```sh
docker exec -it <container_id> sh
```
- Opens a shell inside a running container.  


###  13. Restart a Container üîÑ  
```sh
docker restart <container_id>
```
- Restarts a running or stopped container.  


###  14. Clean Up Unused Resources üßπ  
```sh
docker system prune -a
```
- Deletes **unused** containers, images, and networks.  


###  15. Save & Load Docker Images üíæ  
#### Save an image to a file:
```sh
docker save -o my-image.tar my-node-app
```
- Saves the `my-node-app` image to `my-image.tar`.  

#### Load an image from a file:
```sh
docker load -i my-image.tar
```
- Loads a Docker image from `my-image.tar`.  

# Volumes 

### 1. What is a Docker Volume? üóÑÔ∏è  
Docker **volume** is a storage mechanism that helps persist data outside of the container's filesystem. It allows data to **survive** even after the container stops or is deleted.

#### Why is it Required?  
- Containers have **ephemeral storage**, meaning data inside the container is **lost** when it stops.
- Volumes **persist data** between container restarts.
- They provide **better performance** than bind mounts.
- Volumes allow **multiple containers** to share data.


### 2. Types of Docker Volumes üìÇ  
### 1Ô∏è‚É£ **Anonymous Volume**  
- Docker manages it automatically.
- Removed when the container is deleted.
- Used for **temporary data**.

### 2Ô∏è‚É£ **Named Volume**  
- Created and managed explicitly by the user.
- Can be shared between multiple containers.
- Persistent even after container deletion.

### 3Ô∏è‚É£ **Bind Mount**  
- Maps a **host directory** to a container directory.
- Offers flexibility but can be **risky** (depends on host OS structure).


### 3. Creating and Using Docker Volumes üõ†Ô∏è  

#### **1. Create a Named Volume**
```sh
docker volume create my-volume
```

#### **2. Use a Volume in a Container**
```sh
docker run -d -v my-volume:/app/data --name my-container my-image
```
- `-v my-volume:/app/data` ‚Üí Mounts `my-volume` to `/app/data` in the container.
- Data stored inside `/app/data` will **persist** even if the container stops.

#### **3. Use an Anonymous Volume**
```sh
docker run -d -v /app/data --name my-container my-image
```
- Docker assigns a **random name** to the volume.
- Lost when the container is removed.

#### **4. Use a Bind Mount**
```sh
docker run -d -v $(pwd)/data:/app/data --name my-container my-image
```
- Mounts the **host directory** `$(pwd)/data` to `/app/data` in the container.
- Changes in the container reflect on the **host machine**.


### 4. Managing Docker Volumes 

#### **1. List All Volumes**
```sh
docker volume ls
```

#### **2. Inspect a Volume**
```sh
docker volume inspect my-volume
```
- Shows volume details (path, mount point, etc.).

#### **3. Remove a Volume**
```sh
docker volume rm my-volume
```
- Deletes a specific volume.

#### **4. Remove All Unused Volumes**
```sh
docker volume prune
```
- Deletes **all** unused volumes.


## 5. Sharing Volumes Between Containers
#### **1. Start a Container and Create a Volume**
```sh
docker run -d -v shared-data:/app/data --name container1 my-image
```

#### **2. Start Another Container Using the Same Volume**
```sh
docker run -d -v shared-data:/app/data --name container2 my-image
```
- Both containers **share data** via `shared-data` volume.

